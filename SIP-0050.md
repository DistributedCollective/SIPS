---
SIP: "0050"
Title: Critical governance bug fix
Author: Tyrone Johnson (@tjcloa)
Status: Draft
Track: Contract
Created: 2022-10-18
---

# SIP-0050 : Staking contract critical bug fix - invalid voting power increase

## Description  

The Staking contract has been paused to prevent malicious use of the information disclosed by this SIP.

If approved, this proposal will upgrade the Staking contract to an implementation that fixes a critical bug.

## Motivation

A security researcher has reported a critical bug through Sovryn's Immunefi bug bounty program. The bug allows any address to obtain arbitrarily high voting power that would result in unfair voting weightings. The Exchequer Multisig has paused staking to allow us to expose the bug publicly and to vote on the deployment and acceptance of the fix, without putting our governance at risk in the meantime. It is important to note that this bug has not been exploited on mainnet to date.

## Details

### The bug

Stakers can increase their voting power by using a bug in the Staking contract `extendStakingDuration()` by submitting specific parameters values.

The Staking::extendStakingDuration() function can be used to extend the "until" time for one's stake. It takes 2 parameters: the previous timestamp and the new timestamp. The function takes out the stake amounts and delegation amounts from the previous timestamp and attaches them to the new timestamp. It will also change the delegation in case you delegated to someone else (delegations are timestamp-specific). More specifically, in Staking::extendStakingDuration():

By exploting the bug it was possible to manipulate variables and set `previousLock == until` after and therefore bypassing the initial verification `require(previousLock < until, "S04"); // must increase staking duration`.   

```
address delegateFrom = delegates[msg.sender][previousLock];
address delegateTo = delegates[msg.sender][until];
if (delegateTo == address(0)) {
    delegateTo = delegateFrom;
    delegates[msg.sender][until] = delegateFrom;
}
delegates[msg.sender][previousLock] = address(0);
_decreaseDelegateStake(delegateFrom, previousLock, amount);
_increaseDelegateStake(delegateTo, until, amount);
```

The logic does not work when `previousLock == until`. The stake and delegate balances do indeed decrease and increase correctly. But the line `delegates[msg.sender][previousLock] = address(0)` zeroes out the delegation of the previousLock timestamp, which is the same as the new timestamp.

Now that the delegation address for the currently set staking timestamp is `address(0)`, the attacker can call the `delegate()` function, which will delegate their entire balance as delegateStake to any address, but without decreasing the delegator's delegateStake balance. By repeating this call, the attacker can continuously increase an address' delegateStake without limit (because source voting power is not getting properly decreased) , resulting in arbitrarily high voting power.

### The fix

Move line 143 of Staking.sol `require(previousLock < until, "S04"); // must increase staking duration` to the line 150: 

```
 function extendStakingDuration(uint256 previousLock, uint256 until) public whenNotPaused {
        until = timestampToLockDate(until);
        require(previousLock < until, "S04"); // must increase staking duration

        _notSameBlockAsStakingCheckpoint(previousLock);

        /// @dev Do not exceed the max duration, no overflow possible.
        uint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);
        if (until > latest) until = latest;
```

 to:

```
 function extendStakingDuration(uint256 previousLock, uint256 until) public whenNotPaused {
        until = timestampToLockDate(until);

        _notSameBlockAsStakingCheckpoint(previousLock);

        /// @dev Do not exceed the max duration, no overflow possible.
        uint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);
        if (until > latest) until = latest;
        require(previousLock < until, "S04"); // must increase staking duration
```

This fixes the bug and prevents the delegate address from ever being zeroed out during the staking extensions, and closes the vulnerability.

## Proposed change  

Existing Staking Logic contract: 0x81570497e763809900A8e91c8DaF3020085e43aB  
New Staking Logic contract: _______________________________________________  
Proposed changes: https://github.com/DistributedCollective/Sovryn-smart-contracts/pull/454

## License
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
